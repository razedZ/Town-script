local success, HttpService = pcall(game.GetService, game, "HttpService")
local success2, TweenService = pcall(game.GetService, game, "TweenService")
local success3, UserInputService = pcall(game.GetService, game, "UserInputService")

if not (success and success2 and success3) or not HttpService or not TweenService or not UserInputService then
    warn("Required services are not available. Script may not function fully.")
    return
end

local PizdecWare = {}
PizdecWare.__index = PizdecWare

function PizdecWare:CreateWindow(guiName, infoText, saveConfig)
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Parent = game:GetService("CoreGui")
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.Name = guiName

    -- Main window frame (Layer 1) - initially transparent
    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Parent = ScreenGui
    MainFrame.BackgroundColor3 = Color3.fromRGB(19, 21, 25)
    MainFrame.BorderSizePixel = 0
    MainFrame.Position = UDim2.new(0.032, 0, 0.195, 0)
    MainFrame.Size = UDim2.new(0, 630, 0, 460)
    MainFrame.BackgroundTransparency = 1 -- Start transparent
    MainFrame.Active = true
    MainFrame.ZIndex = 1

    local UICorner = Instance.new("UICorner")
    UICorner.Parent = MainFrame

    -- Improved dragging functionality
    local dragging = false
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end

    MainFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = MainFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    MainFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)

    -- Logo with P and W letters
    local Logo = Instance.new("Frame")
    Logo.Name = "Logo"
    Logo.Parent = MainFrame
    Logo.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
    Logo.Size = UDim2.new(0, 25, 0, 25)
    Logo.Position = UDim2.new(0.022, 0, 0.031, 0)
    Logo.ZIndex = 3
    Logo.BackgroundTransparency = 1 -- Start transparent

    local UICorner_17 = Instance.new("UICorner")
    UICorner_17.Parent = Logo

    -- W letter
    local W = Instance.new("TextLabel")
    W.Name = "W"
    W.Parent = Logo
    W.BackgroundTransparency = 1
    W.Position = UDim2.new(0.282, 0, 0.76, 0)
    W.Size = UDim2.new(0, 23, 0, -14)
    W.ZIndex = 4
    W.Font = Enum.Font.SourceSansBold
    W.Text = "W"
    W.TextColor3 = Color3.fromRGB(0, 0, 0)
    W.TextSize = 20
    W.TextTransparency = 1 -- Start transparent

    -- P letter
    local P = Instance.new("TextLabel")
    P.Name = "P"
    P.Parent = Logo
    P.BackgroundTransparency = 1
    P.Position = UDim2.new(-0.304, 0, 0.76, 0)
    P.Size = UDim2.new(0, 27, 0, -14)
    P.ZIndex = 4
    P.Font = Enum.Font.SourceSansBold
    P.Text = "P"
    P.TextColor3 = Color3.fromRGB(255, 255, 255)
    P.TextSize = 20
    P.TextTransparency = 1 -- Start transparent

    -- PizdecWare label
    local PizdecWareLabel = Instance.new("TextLabel")
    PizdecWareLabel.Name = "PizdecWare"
    PizdecWareLabel.Parent = Logo
    PizdecWareLabel.BackgroundTransparency = 1
    PizdecWareLabel.Position = UDim2.new(2.2, 0, 1.3, 0)
    PizdecWareLabel.Size = UDim2.new(0, 60, 0, -41)
    PizdecWareLabel.Font = Enum.Font.SourceSansBold
    PizdecWareLabel.Text = "PizdecWare"
    PizdecWareLabel.TextColor3 = Color3.fromRGB(150, 17, 255)
    PizdecWareLabel.TextSize = 25
    PizdecWareLabel.TextTransparency = 1 -- Start transparent

    local Info = Instance.new("TextLabel")
    Info.Name = "Info"
    Info.Parent = MainFrame
    Info.BackgroundTransparency = 1
    Info.Position = UDim2.new(0.054, 0, 0.083, 0)
    Info.Size = UDim2.new(0, 116, 0, 10)
    Info.Font = Enum.Font.SourceSansBold
    Info.Text = infoText or ""
    Info.TextColor3 = Color3.fromRGB(170, 176, 183)
    Info.TextSize = 10
    Info.TextXAlignment = Enum.TextXAlignment.Right
    Info.TextTransparency = 1 -- Start transparent

    -- Main container - initially transparent
    local ElementContainer = Instance.new("ScrollingFrame")
    ElementContainer.Name = "ElementContainer"
    ElementContainer.Parent = MainFrame
    ElementContainer.BackgroundColor3 = Color3.fromRGB(23, 24, 28)
    ElementContainer.Position = UDim2.new(0.259, 0, 0.116, 0)
    ElementContainer.Size = UDim2.new(0, 460, 0, 400)
    ElementContainer.ZIndex = 1
    ElementContainer.BackgroundTransparency = 1 -- Start transparent
    ElementContainer.ScrollBarThickness = 8
    ElementContainer.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    ElementContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
    ElementContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y

    local UICorner_2 = Instance.new("UICorner")
    UICorner_2.Parent = ElementContainer

    local UIStroke = Instance.new("UIStroke")
    UIStroke.Parent = ElementContainer
    UIStroke.Color = Color3.fromRGB(0, 0, 0)
    UIStroke.Thickness = 1
    UIStroke.Transparency = 0.8

    -- Section containers
    local LeftContainer = Instance.new("Frame")
    LeftContainer.Name = "LeftContainer"
    LeftContainer.Parent = ElementContainer
    LeftContainer.BackgroundTransparency = 1
    LeftContainer.Position = UDim2.new(0, 20, 0, 20)
    LeftContainer.Size = UDim2.new(0.5, -30, 1, -40)

    local RightContainer = Instance.new("Frame")
    RightContainer.Name = "RightContainer"
    RightContainer.Parent = ElementContainer
    RightContainer.BackgroundTransparency = 1
    RightContainer.Position = UDim2.new(0.5, 10, 0, 20)
    RightContainer.Size = UDim2.new(0.5, -30, 1, -40)

    -- Fade in animation function
    local function fadeIn(element)
        if not TweenService then return end
        local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.In)
        
        if element:IsA("TextLabel") or element:IsA("TextButton") then
            local tween = TweenService:Create(element, tweenInfo, {TextTransparency = 0})
            tween:Play()
        elseif element:IsA("ImageLabel") or element:IsA("ImageButton") then
            local tween = TweenService:Create(element, tweenInfo, {ImageTransparency = 0})
            tween:Play()
        elseif element:IsA("Frame") and element.Name:find("Toggle_") then
            -- Skip transparency animation for toggle containers
            return
        else
            local tween = TweenService:Create(element, tweenInfo, {BackgroundTransparency = 0})
            tween:Play()
        end
    end

    -- Create window instance to return
    local windowInstance = setmetatable({
        _tabZone = nil,
        _selectedTab = nil,
        _currentTab = nil,
        _tabSections = {},
        _initialized = false,
        _leftSections = {},
        _rightSections = {},
        _elementContainer = ElementContainer,
        _sectionStates = {}, -- Track expanded/collapsed state
        _toggleElements = {}, -- Track toggle elements
        _dropdownElements = {}, -- Track dropdown elements
        _saveConfig = saveConfig or { enabled = false, fileName = "PizdecWareSettings" },
        _savedToggles = {},
        _savedDropdowns = {},
        _openDropdowns = {} -- Track open dropdowns
    }, PizdecWare)

    -- Load saved toggles and dropdowns
    if windowInstance._saveConfig.enabled and HttpService then
        local success, savedData = pcall(function()
            if not isfile(windowInstance._saveConfig.fileName..".json") then
                return {}
            end
            local data = game:GetService("HttpService"):JSONDecode(readfile(windowInstance._saveConfig.fileName..".json")) or {}
            return data
        end)
        
        if success and savedData then
            windowInstance._savedToggles = savedData.toggles or {}
            windowInstance._savedDropdowns = savedData.dropdowns or {}
        end
    end

    -- Function to save toggle state
    local function saveToggleState(window, toggleName, state)
        if not window._saveConfig.enabled or not HttpService then return end
        
        window._savedToggles[toggleName] = state
        
        pcall(function()
            local data = {
                toggles = window._savedToggles,
                dropdowns = window._savedDropdowns
            }
            writefile(window._saveConfig.fileName..".json", HttpService:JSONEncode(data))
        end)
    end

    -- Function to load toggle state
    local function loadToggleState(window, toggleName)
        if not window._saveConfig.enabled or not window._savedToggles then return nil end
        return window._savedToggles[toggleName]
    end

    -- Function to save dropdown state
    local function saveDropdownState(window, dropdownName, value)
        if not window._saveConfig.enabled or not HttpService then return end
        
        window._savedDropdowns[dropdownName] = value
        
        pcall(function()
            local data = {
                toggles = window._savedToggles,
                dropdowns = window._savedDropdowns
            }
            writefile(window._saveConfig.fileName..".json", HttpService:JSONEncode(data))
        end)
    end

    -- Function to load dropdown state
    local function loadDropdownState(window, dropdownName)
        if not window._saveConfig.enabled or not window._savedDropdowns then return nil end
        return window._savedDropdowns[dropdownName]
    end

    -- Function to update positions of all sections with synchronized animation
    local function updateSectionPositions(container, sections)
        local yOffset = 0
        local totalHeight = 0
        
        -- First pass: calculate target positions
        local targetPositions = {}
        for i, section in ipairs(sections) do
            if section.Visible then
                targetPositions[section] = UDim2.new(0, 0, 0, yOffset)
                
                if windowInstance._sectionStates[section] == false then -- Collapsed
                    yOffset = yOffset + 30 + 20
                else -- Expanded
                    local contentFrame = section:FindFirstChild("ContentFrame")
                    local contentHeight = 0
                    if contentFrame then
                        for _, element in ipairs(contentFrame:GetChildren()) do
                            if element:IsA("Frame") and (element.Name:match("^Toggle_") or element.Name:match("^Dropdown_")) then
                                contentHeight = contentHeight + element.Size.Y.Offset + 7 -- 7px spacing between elements
                            end
                        end
                        contentHeight = math.max(contentHeight - 7, 0) -- Remove extra spacing at the end
                    end
                    local sectionHeight = 30 + contentHeight + 10 -- Header + content + 10px bottom padding
                    yOffset = yOffset + sectionHeight + 20
                end
                totalHeight = yOffset
            end
        end
        
        -- Second pass: apply new positions
        for section, position in pairs(targetPositions) do
            local tween = TweenService:Create(
                section,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad),
                {Position = position}
            )
            tween:Play()
        end
        
        windowInstance._elementContainer.CanvasSize = UDim2.new(0, 0, 0, totalHeight + 40)
    end

    -- Initialize UI elements
    coroutine.wrap(function()
        fadeIn(MainFrame)
        fadeIn(ElementContainer)
        wait(0.2)
        
        fadeIn(Logo)
        fadeIn(W)
        fadeIn(P)
        fadeIn(PizdecWareLabel)
        fadeIn(Info)
        wait(0.3)
        
        windowInstance._tabZone = Instance.new("Frame")
        windowInstance._tabZone.Name = "TabZone"
        windowInstance._tabZone.Parent = MainFrame
        windowInstance._tabZone.BackgroundTransparency = 1
        windowInstance._tabZone.Position = UDim2.new(0, 0, 0.116, 0)
        windowInstance._tabZone.Size = UDim2.new(0, 163, 0, 399)
        windowInstance._tabZone.ZIndex = 1

        local Tabs = Instance.new("TextLabel")
        Tabs.Name = "Tabs"
        Tabs.Parent = windowInstance._tabZone
        Tabs.BackgroundTransparency = 1
        Tabs.Position = UDim2.new(0.045, 0, 0, 0)
        Tabs.Size = UDim2.new(0, 50, 0, 20)
        Tabs.Font = Enum.Font.ArialBold
        Tabs.Text = "Tabs"
        Tabs.TextColor3 = Color3.fromRGB(147, 152, 156)
        Tabs.TextSize = 14
        Tabs.TextXAlignment = Enum.TextXAlignment.Left
        Tabs.ZIndex = 1
        fadeIn(Tabs)

        windowInstance._selectedTab = Instance.new("Frame")
        windowInstance._selectedTab.Name = "SelectedTab"
        windowInstance._selectedTab.Parent = windowInstance._tabZone
        windowInstance._selectedTab.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
        windowInstance._selectedTab.BackgroundTransparency = 0.9
        windowInstance._selectedTab.Position = UDim2.new(0, 0, 0, 23)
        windowInstance._selectedTab.Size = UDim2.new(0, 163, 0, 30)
        windowInstance._selectedTab.ZIndex = 2
        fadeIn(windowInstance._selectedTab)

        local CloseButton = Instance.new("ImageButton")
        CloseButton.Name = "CloseButton"
        CloseButton.Parent = MainFrame
        CloseButton.BackgroundTransparency = 1
        CloseButton.Position = UDim2.new(0.949, 0, 0.017, 0)
        CloseButton.Size = UDim2.new(0, 25, 0, 25)
        CloseButton.Image = "rbxassetid://12653789995"
        CloseButton.ZIndex = 3
        fadeIn(CloseButton)
        CloseButton.MouseButton1Click:Connect(function()
            ScreenGui:Destroy()
        end)

        windowInstance._initialized = true
    end)()

    function windowInstance:CreateTab(visualName, imageId)
        while not self._initialized do wait() end
        
        local tabCount = 0
        for _, child in ipairs(self._tabZone:GetChildren()) do
            if child:IsA("TextLabel") and child.Name ~= "Tabs" then
                tabCount = tabCount + 1
            end
        end
        
        local initialOffset = (23 + (tabCount * 30)) / self._tabZone.AbsoluteSize.Y
        
        local tab = Instance.new("TextLabel")
        tab.Name = visualName
        tab.Parent = self._tabZone
        tab.BackgroundTransparency = 1
        tab.Position = UDim2.new(0.307, 0, initialOffset, 0)
        tab.Size = UDim2.new(0, 101, 0, 28)
        tab.Font = Enum.Font.SourceSansBold
        tab.Text = visualName
        tab.TextColor3 = Color3.fromRGB(147, 152, 156)
        tab.TextSize = 20
        tab.TextXAlignment = Enum.TextXAlignment.Left
        tab.ZIndex = 3
        fadeIn(tab)

        local image = Instance.new("ImageLabel")
        image.Name = "TabImage"
        image.Parent = tab
        image.BackgroundTransparency = 1
        image.Position = UDim2.new(-0.365, 0, 0.037, 0)
        image.Size = UDim2.new(0, 26, 0, 26)
        image.ZIndex = 3
        image.Image = "rbxassetid://" .. imageId
        image.ImageColor3 = Color3.fromRGB(147, 152, 156)
        fadeIn(image)

        local function selectTab()
            if not TweenService or not self._selectedTab then return end
            
            local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Linear)
            
            for _, child in ipairs(self._tabZone:GetChildren()) do
                if child:IsA("TextLabel") and child ~= tab and child.Name ~= "Tabs" then
                    local childImage = child:FindFirstChild("TabImage")
                    TweenService:Create(child, tweenInfo, {TextColor3 = Color3.fromRGB(147, 152, 156)}):Play()
                    if childImage then
                        TweenService:Create(childImage, tweenInfo, {ImageColor3 = Color3.fromRGB(147, 152, 156)}):Play()
                    end
                end
            end
            
            TweenService:Create(tab, tweenInfo, {TextColor3 = Color3.fromRGB(150, 17, 255)}):Play()
            TweenService:Create(image, tweenInfo, {ImageColor3 = Color3.fromRGB(150, 17, 255)}):Play()

            local newPosition = UDim2.new(0, 0, tab.Position.Y.Scale, 0)
            local moveTween = TweenService:Create(
                self._selectedTab, 
                TweenInfo.new(0.1, Enum.EasingStyle.Linear),
                {Position = newPosition, BackgroundTransparency = 0.9}
            )
            moveTween:Play()
            
            moveTween.Completed:Connect(function()
                self._selectedTab.BackgroundTransparency = 0.9
            end)

            for tabName, sections in pairs(self._tabSections) do
                for _, section in ipairs(sections) do
                    section.Visible = (tabName == tab.Name)
                end
            end

            for _, sections in pairs({self._leftSections, self._rightSections}) do
                updateSectionPositions(nil, sections)
            end

            self._currentTab = tab
        end

        tab.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                selectTab()
            end
        end)

        image.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                selectTab()
            end
        end)

        if not self._currentTab then
            selectTab()
        end

        self._tabSections[tab.Name] = {}

        return tab
    end

    function windowInstance:CreateSection(sectionName, tab, side)
        if not tab then return nil end
        
        local container = (side == "left" and LeftContainer) or (side == "right" and RightContainer) or LeftContainer
        local sectionsList = (side == "left" and self._leftSections) or (side == "right" and self._rightSections) or self._leftSections
        
        local yOffset = 0
        for _, section in ipairs(sectionsList) do
            if section.Visible then
                if windowInstance._sectionStates[section] == false then
                    yOffset = yOffset + 30 + 20
                else
                    local contentFrame = section:FindFirstChild("ContentFrame")
                    local contentHeight = 0
                    if contentFrame then
                        for _, element in ipairs(contentFrame:GetChildren()) do
                            if element:IsA("Frame") and (element.Name:match("^Toggle_") or element.Name:match("^Dropdown_")) then
                                contentHeight = contentHeight + element.Size.Y.Offset + 7
                            end
                        end
                        contentHeight = math.max(contentHeight - 7, 0)
                    end
                    local sectionHeight = 30 + contentHeight + 10
                    yOffset = yOffset + sectionHeight + 20
                end
            end
        end

        local section = Instance.new("Frame")
        section.Name = sectionName
        section.Parent = container
        section.BackgroundColor3 = Color3.fromRGB(17, 19, 23)
        section.Position = UDim2.new(0, 0, 0, yOffset)
        section.Size = UDim2.new(1, 0, 0, 30)
        section.ZIndex = 4
        section.Visible = (tab == self._currentTab)
        section.ClipsDescendants = true
        fadeIn(section)

        windowInstance._sectionStates[section] = true

        local UICornerSection = Instance.new("UICorner")
        UICornerSection.CornerRadius = UDim.new(0, 3)
        UICornerSection.Parent = section

        local HeaderContainer = Instance.new("Frame")
        HeaderContainer.Name = "HeaderContainer"
        HeaderContainer.Parent = section
        HeaderContainer.BackgroundTransparency = 1
        HeaderContainer.Size = UDim2.new(1, 0, 0, 30)
        HeaderContainer.ZIndex = 5

        local SectionLabel = Instance.new("TextLabel")
        SectionLabel.Name = "Label"
        SectionLabel.Parent = HeaderContainer
        SectionLabel.BackgroundTransparency = 1
        SectionLabel.Position = UDim2.new(0.085, 0, 0.15, 0)
        SectionLabel.Size = UDim2.new(0, 100, 0, 20)
        SectionLabel.Font = Enum.Font.ArialBold
        SectionLabel.Text = sectionName
        SectionLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
        SectionLabel.TextSize = 14
        SectionLabel.TextXAlignment = Enum.TextXAlignment.Left
        SectionLabel.ZIndex = 5
        fadeIn(SectionLabel)

        local ShowSectionButton = Instance.new("TextButton")
        ShowSectionButton.Name = "ShowSection"
        ShowSectionButton.Parent = HeaderContainer
        ShowSectionButton.BackgroundTransparency = 1
        ShowSectionButton.Position = UDim2.new(0.86, 0, 0.15, 0)
        ShowSectionButton.Size = UDim2.new(0, 20, 0, 20)
        ShowSectionButton.Font = Enum.Font.SourceSans
        ShowSectionButton.Text = "▼"
        ShowSectionButton.TextColor3 = Color3.fromRGB(147, 152, 156)
        ShowSectionButton.TextSize = 14
        ShowSectionButton.ZIndex = 5
        fadeIn(ShowSectionButton)

        local SectionLine = Instance.new("Frame")
        SectionLine.Name = "Line"
        SectionLine.Parent = HeaderContainer
        SectionLine.BackgroundColor3 = Color3.fromRGB(66, 63, 71)
        SectionLine.Position = UDim2.new(0.045, 0, 1, 0)
        SectionLine.Size = UDim2.new(0.91, 0, 0, 1)
        SectionLine.ZIndex = 4
        fadeIn(SectionLine)

        local ContentFrame = Instance.new("Frame")
        ContentFrame.Name = "ContentFrame"
        ContentFrame.Parent = section
        ContentFrame.BackgroundColor3 = Color3.fromRGB(17, 19, 23)
        ContentFrame.BackgroundTransparency = 1
        ContentFrame.Position = UDim2.new(0, 0, 0, 31)
        ContentFrame.Size = UDim2.new(1, 0, 0, 0)
        ContentFrame.ZIndex = 4
        ContentFrame.ClipsDescendants = true

        local collapsedSize = UDim2.new(1, 0, 0, 30)

        local function toggleSection()
            if not TweenService then return end
            
            local isExpanded = windowInstance._sectionStates[section]
            windowInstance._sectionStates[section] = not isExpanded
            
            if not isExpanded then
                ShowSectionButton.Text = "▼"
                ContentFrame.BackgroundTransparency = 1
                
                for _, element in pairs(self._toggleElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = true
                        element.BackgroundTransparency = 1
                    end
                end
                for _, element in pairs(self._dropdownElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = true
                        element.BackgroundTransparency = 1
                    end
                end
                
                local contentHeight = 0
                for _, element in ipairs(ContentFrame:GetChildren()) do
                    if element:IsA("Frame") and (element.Name:match("^Toggle_") or element.Name:match("^Dropdown_")) then
                        contentHeight = contentHeight + element.Size.Y.Offset + 7
                    end
                end
                contentHeight = math.max(contentHeight - 7, 0)
                ContentFrame.Size = UDim2.new(1, 0, 0, contentHeight)
                
                local sizeTween = TweenService:Create(
                    section,
                    TweenInfo.new(0.3, Enum.EasingStyle.Quad),
                    {Size = UDim2.new(1, 0, 0, 30 + contentHeight + 10)}
                )
                sizeTween:Play()
            else
                ShowSectionButton.Text = "▲"
                
                for _, element in pairs(self._toggleElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = false
                        element.BackgroundTransparency = 1
                    end
                end
                for _, element in pairs(self._dropdownElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = false
                        element.BackgroundTransparency = 1
                    end
                end
                
                for dropdownContainer, dropdownList in pairs(self._openDropdowns) do
                    if dropdownContainer:IsDescendantOf(section) then
                        dropdownList.Visible = false
                        dropdownList.Size = UDim2.new(0, 165, 0, 0)
                        self._openDropdowns[dropdownContainer] = nil
                    end
                end
                
                ContentFrame.Size = UDim2.new(1, 0, 0, 0)
                local sizeTween = TweenService:Create(
                    section,
                    TweenInfo.new(0.3, Enum.EasingStyle.Quad),
                    {Size = collapsedSize}
                )
                sizeTween:Play()
            end
            
            updateSectionPositions(container, sectionsList)
        end

        ShowSectionButton.MouseButton1Click:Connect(toggleSection)

        if not self._tabSections[tab.Name] then
            self._tabSections[tab.Name] = {}
        end
        table.insert(self._tabSections[tab.Name], section)
        table.insert(sectionsList, section)
        
        updateSectionPositions(container, sectionsList)

        return section
    end

    function windowInstance:CreateToggle(section, toggleName, defaultValue, save, callback)
        if not section then return nil end
        
        local ContentFrame = section:FindFirstChild("ContentFrame")
        if not ContentFrame then return nil end
        
        if save and self._saveConfig.enabled then
            local savedState = loadToggleState(self, toggleName)
            if savedState ~= nil then
                defaultValue = savedState
            end
        end
        
        local yOffset = 0
        for _, element in pairs(self._toggleElements) do
            if element.Parent == ContentFrame then
                yOffset = yOffset + element.Size.Y.Offset + 7
            end
        end
        for _, element in pairs(self._dropdownElements) do
            if element.Parent == ContentFrame then
                yOffset = yOffset + element.Size.Y.Offset + 7
            end
        end

        local ToggleContainer = Instance.new("Frame")
        ToggleContainer.Name = "Toggle_" .. toggleName
        ToggleContainer.Parent = ContentFrame
        ToggleContainer.BackgroundTransparency = 1
        ToggleContainer.Size = UDim2.new(1, 0, 0, 30)
        ToggleContainer.Position = UDim2.new(0, 0, 0, yOffset)
        ToggleContainer.ZIndex = 5
        ToggleContainer.Visible = true

        local ToggleButton = Instance.new("TextButton")
        ToggleButton.Name = "Button"
        ToggleButton.Parent = ToggleContainer
        ToggleButton.BackgroundColor3 = defaultValue and Color3.fromRGB(150, 17, 255) or Color3.fromRGB(24, 29, 32)
        ToggleButton.BorderSizePixel = 0
        ToggleButton.Position = UDim2.new(0.085, 0, 0.1, 0)
        ToggleButton.Size = UDim2.new(0, 20, 0, 20)
        ToggleButton.Text = ""
        ToggleButton.ZIndex = 6

        local UICornerToggle = Instance.new("UICorner")
        UICornerToggle.CornerRadius = UDim.new(0, 4)
        UICornerToggle.Parent = ToggleButton

        local Checkmark = Instance.new("TextLabel")
        Checkmark.Name = "Checkmark"
        Checkmark.Parent = ToggleButton
        Checkmark.BackgroundTransparency = 1
        Checkmark.Size = UDim2.new(1, 0, 1, 0)
        Checkmark.Text = "✔️"
        Checkmark.TextColor3 = Color3.fromRGB(24, 29, 32)
        Checkmark.TextSize = 10
        Checkmark.ZIndex = 7
        Checkmark.Visible = defaultValue

        local ToggleText = Instance.new("TextLabel")
        ToggleText.Name = "Text"
        ToggleText.Parent = ToggleContainer
        ToggleText.BackgroundTransparency = 1
        ToggleText.Position = UDim2.new(0.15, 20, 0, 0)
        ToggleText.Size = UDim2.new(0.85, -20, 1, 0)
        ToggleText.Font = Enum.Font.SourceSansBold
        ToggleText.Text = toggleName
        ToggleText.TextColor3 = Color3.fromRGB(147, 152, 156)
        ToggleText.TextSize = 17
        ToggleText.TextXAlignment = Enum.TextXAlignment.Left
        ToggleText.ZIndex = 6

        local isToggled = defaultValue or false
        
        ToggleButton.MouseButton1Click:Connect(function()
            isToggled = not isToggled
            
            if isToggled then
                ToggleButton.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
                Checkmark.Visible = true
            else
                ToggleButton.BackgroundColor3 = Color3.fromRGB(24, 29, 32)
                Checkmark.Visible = false
            end
            
            if save and self._saveConfig.enabled then
                saveToggleState(self, toggleName, isToggled)
            end
            
            if callback then
                callback(isToggled)
            end
        end)
        
        table.insert(self._toggleElements, ToggleContainer)
        
        local sectionsList = table.find(self._leftSections, section) and self._leftSections or self._rightSections
        local container = sectionsList == self._leftSections and LeftContainer or RightContainer
        
        local contentHeight = 0
        for _, element in pairs(self._toggleElements) do
            if element.Parent == ContentFrame then
                contentHeight = contentHeight + element.Size.Y.Offset + 7
            end
        end
        for _, element in pairs(self._dropdownElements) do
            if element.Parent == ContentFrame then
                contentHeight = contentHeight + element.Size.Y.Offset + 7
            end
        end
        contentHeight = math.max(contentHeight - 7, 0)
        
        if windowInstance._sectionStates[section] then
            section.Size = UDim2.new(1, 0, 0, 30 + contentHeight + 10)
            ContentFrame.Size = UDim2.new(1, 0, 0, contentHeight)
        end
        
        updateSectionPositions(container, sectionsList)
        
        return {
            Set = function(self, value)
                isToggled = value
                
                if isToggled then
                    ToggleButton.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
                    Checkmark.Visible = true
                else
                    ToggleButton.BackgroundColor3 = Color3.fromRGB(24, 29, 32)
                    Checkmark.Visible = false
                end
                
                if save and windowInstance._saveConfig.enabled then
                    saveToggleState(windowInstance, toggleName, isToggled)
                end
                
                if callback then
                    callback(isToggled)
                end
            end,
            Get = function(self)
                return isToggled
            end
        }
    end

    function windowInstance:CreateDropdown(section, dropdownName, options, defaultOption, multi, save, callback)
        if not section then return nil end
        
        local ContentFrame = section:FindFirstChild("ContentFrame")
        if not ContentFrame then return nil end
        
        if save and self._saveConfig.enabled then
            local savedState = loadDropdownState(self, dropdownName)
            if savedState ~= nil then
                if multi then
                    defaultOption = savedState
                else
                    if table.find(options, savedState) then
                        defaultOption = savedState
                    end
                end
            end
        end
        
        local yOffset = 0
        for _, element in pairs(self._toggleElements) do
            if element.Parent == ContentFrame then
                yOffset = yOffset + element.Size.Y.Offset + 7
            end
        end
        for _, element in pairs(self._dropdownElements) do
            if element.Parent == ContentFrame then
                yOffset = yOffset + element.Size.Y.Offset + 7
            end
        end
        
        -- Dropdown container
        local DropdownContainer = Instance.new("Frame")
        DropdownContainer.Name = "Dropdown_" .. dropdownName
        DropdownContainer.Parent = ContentFrame
        DropdownContainer.BackgroundTransparency = 1
        DropdownContainer.Size = UDim2.new(1, 0, 0, 50)
        DropdownContainer.Position = UDim2.new(0, 0, 0, yOffset)
        DropdownContainer.ZIndex = 5
        DropdownContainer.Visible = true
        
        -- Dropdown label
        local DropdownLabel = Instance.new("TextLabel")
        DropdownLabel.Name = "Label"
        DropdownLabel.Parent = DropdownContainer
        DropdownLabel.BackgroundTransparency = 1
        DropdownLabel.Position = UDim2.new(0.085, 0, 0, 0)
        DropdownLabel.Size = UDim2.new(0, 165, 0, 20)
        DropdownLabel.Font = Enum.Font.SourceSansBold
        DropdownLabel.Text = dropdownName
        DropdownLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
        DropdownLabel.TextSize = 15
        DropdownLabel.TextXAlignment = Enum.TextXAlignment.Left
        DropdownLabel.ZIndex = 6
        
        -- Dropdown button
        local DropdownButton = Instance.new("TextButton")
        DropdownButton.Name = "Button"
        DropdownButton.Parent = DropdownContainer
        DropdownButton.BackgroundColor3 = Color3.fromRGB(25, 28, 34)
        DropdownButton.BorderSizePixel = 0
        DropdownButton.Position = UDim2.new(0.085, 0, 0, 20)
        DropdownButton.Size = UDim2.new(0, 165, 0, 30)
        DropdownButton.Font = Enum.Font.SourceSans
        DropdownButton.Text = ""
        DropdownButton.TextColor3 = Color3.fromRGB(147, 152, 156)
        DropdownButton.TextSize = 14
        DropdownButton.ZIndex = 6
        
        local UICornerDropdown = Instance.new("UICorner")
        UICornerDropdown.CornerRadius = UDim.new(0, 4)
        UICornerDropdown.Parent = DropdownButton
        
        -- Selected option text
        local SelectedText = Instance.new("TextLabel")
        SelectedText.Name = "SelectedText"
        SelectedText.Parent = DropdownButton
        SelectedText.BackgroundTransparency = 1
        SelectedText.Position = UDim2.new(0.05, 0, 0, 0)
        SelectedText.Size = UDim2.new(0.9, 0, 1, 0)
        SelectedText.Font = Enum.Font.SourceSans
        SelectedText.Text = ""
        SelectedText.TextColor3 = Color3.fromRGB(147, 152, 156)
        SelectedText.TextSize = 14
        SelectedText.TextXAlignment = Enum.TextXAlignment.Left
        SelectedText.ZIndex = 7
        
        -- Dropdown list frame (будет поверх всего UI)
        local DropdownList = Instance.new("Frame")
        DropdownList.Name = "DropdownList"
        DropdownList.Parent = ScreenGui -- Parent to ScreenGui to be above everything
        DropdownList.BackgroundColor3 = Color3.fromRGB(25, 28, 34)
        DropdownList.BorderSizePixel = 0
        DropdownList.Size = UDim2.new(0, 165, 0, 0) -- Will be updated when opened
        DropdownList.Visible = false
        DropdownList.ZIndex = 100 -- High z-index to be above everything
        DropdownList.ClipsDescendants = true
        
        local UICornerList = Instance.new("UICorner")
        UICornerList.CornerRadius = UDim.new(0, 4)
        UICornerList.Parent = DropdownList
        
        local ScrollingFrame = Instance.new("ScrollingFrame")
        ScrollingFrame.Parent = DropdownList
        ScrollingFrame.Size = UDim2.new(1, 0, 1, 0)
        ScrollingFrame.BackgroundTransparency = 1
        ScrollingFrame.ScrollBarThickness = 5
        ScrollingFrame.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
        ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, 0)
        
        local UIListLayout = Instance.new("UIListLayout")
        UIListLayout.Parent = ScrollingFrame
        UIListLayout.SortOrder = Enum.SortOrder.LayoutOrder
        
        -- Initialize selected options
        local selectedOptions = {}
        if multi then
            if type(defaultOption) == "table" then
                for _, option in ipairs(defaultOption) do
                    if table.find(options, option) then
                        selectedOptions[option] = true
                    end
                end
            end
        else
            if table.find(options, defaultOption) then
                selectedOptions[defaultOption] = true
            end
        end
        
        -- Update selected text display
        local function updateSelectedText()
            if multi then
                local count = 0
                for _ in pairs(selectedOptions) do
                    count = count + 1
                end
                
                if count == 0 then
                    SelectedText.Text = "None selected"
                elseif count == 1 then
                    for option in pairs(selectedOptions) do
                        SelectedText.Text = option
                        break
                    end
                else
                    SelectedText.Text = count .. " selected"
                end
            else
                for option in pairs(selectedOptions) do
                    SelectedText.Text = option
                    return
                end
                SelectedText.Text = "Select option"
            end
        end
        
        updateSelectedText()
        
        -- Create option buttons
        local function createOptionButtons()
            -- Clear existing options
            for _, child in ipairs(ScrollingFrame:GetChildren()) do
                if child:IsA("TextButton") then
                    child:Destroy()
                end
            end
            
            -- Create new options
            for _, option in ipairs(options) do
                local OptionButton = Instance.new("TextButton")
                OptionButton.Name = "Option_" .. option
                OptionButton.Parent = ScrollingFrame
                OptionButton.BackgroundColor3 = Color3.fromRGB(25, 28, 34)
                OptionButton.BorderSizePixel = 0
                OptionButton.Size = UDim2.new(1, 0, 0, 20)
                OptionButton.Font = Enum.Font.SourceSans
                OptionButton.Text = option
                OptionButton.TextColor3 = selectedOptions[option] and Color3.fromRGB(150, 17, 255) or Color3.fromRGB(147, 152, 156)
                OptionButton.TextSize = 14
                OptionButton.ZIndex = 101 -- Higher than dropdown list
                
                OptionButton.MouseButton1Click:Connect(function()
                    if multi then
                        if selectedOptions[option] then
                            selectedOptions[option] = nil
                        else
                            selectedOptions[option] = true
                        end
                        OptionButton.TextColor3 = selectedOptions[option] and Color3.fromRGB(150, 17, 255) or Color3.fromRGB(147, 152, 156)
                    else
                        -- Clear previous selection
                        for opt in pairs(selectedOptions) do
                            selectedOptions[opt] = nil
                        end
                        
                        selectedOptions[option] = true
                        
                        -- Update all option colors
                        for _, btn in ipairs(ScrollingFrame:GetChildren()) do
                            if btn:IsA("TextButton") then
                                btn.TextColor3 = btn == OptionButton and Color3.fromRGB(150, 17, 255) or Color3.fromRGB(147, 152, 156)
                            end
                        end
                        
                        -- Close dropdown after selection
                        DropdownList.Visible = false
                        DropdownList.Size = UDim2.new(0, 165, 0, 0)
                        self._openDropdowns[DropdownContainer] = nil
                    end
                    
                    updateSelectedText()
                    
                    -- Save state if needed
                    if save and self._saveConfig.enabled then
                        if multi then
                            local selected = {}
                            for opt in pairs(selectedOptions) do
                                table.insert(selected, opt)
                            end
                            saveDropdownState(self, dropdownName, selected)
                        else
                            for opt in pairs(selectedOptions) do
                                saveDropdownState(self, dropdownName, opt)
                                break
                            end
                        end
                    end
                    
                    if callback then
                        if multi then
                            local selected = {}
                            for opt in pairs(selectedOptions) do
                                table.insert(selected, opt)
                            end
                            callback(selected)
                        else
                            for opt in pairs(selectedOptions) do
                                callback(opt)
                                break
                            end
                        end
                    end
                end)
            end
            
            -- Update dropdown list size (максимум 4 опции с скроллом)
            local optionCount = #options
            local maxHeight = math.min(4, optionCount) * 20 -- Max 4 options visible
            ScrollingFrame.CanvasSize = UDim2.new(0, 0, 0, optionCount * 20)
        end
        
        createOptionButtons()
        
        -- Toggle dropdown visibility
        local isDropdownOpen = false
        
        local function updateDropdownPosition()
            local buttonPos = DropdownButton.AbsolutePosition
            local buttonSize = DropdownButton.AbsoluteSize
            
            DropdownList.Position = UDim2.new(
                0, buttonPos.X,
                0, buttonPos.Y + buttonSize.Y
            )
        end
        
        local function toggleDropdown()
            isDropdownOpen = not isDropdownOpen
            DropdownList.Visible = isDropdownOpen
            
            if isDropdownOpen then
                updateDropdownPosition()
                -- Bring to front
                DropdownList.ZIndex = 100
                for _, btn in ipairs(ScrollingFrame:GetChildren()) do
                    if btn:IsA("TextButton") then
                        btn.ZIndex = 101
                    end
                end
                -- Set size on open
                local optionCount = #options
                local maxHeight = math.min(4, optionCount) * 20
                DropdownList.Size = UDim2.new(0, 165, 0, maxHeight)
                -- Track open dropdown
                self._openDropdowns[DropdownContainer] = DropdownList
            else
                DropdownList.Size = UDim2.new(0, 165, 0, 0)
                self._openDropdowns[DropdownContainer] = nil
            end
        end
        
        DropdownButton.MouseButton1Click:Connect(function()
            -- Close other open dropdowns first
            for container, list in pairs(self._openDropdowns) do
                if container ~= DropdownContainer then
                    list.Visible = false
                    list.Size = UDim2.new(0, 165, 0, 0)
                    self._openDropdowns[container] = nil
                end
            end
            
            toggleDropdown()
        end)
        
        -- Update position when window moves
        MainFrame:GetPropertyChangedSignal("Position"):Connect(function()
            if isDropdownOpen then
                updateDropdownPosition()
            end
        end)
        
        -- Update position when scrolling the element container
        ElementContainer:GetPropertyChangedSignal("CanvasPosition"):Connect(function()
            if isDropdownOpen then
                updateDropdownPosition()
            end
        end)
        
        -- Close dropdown when clicking outside
        UserInputService.InputBegan:Connect(function(input, gameProcessed)
            if gameProcessed then return end
            
            if input.UserInputType == Enum.UserInputType.MouseButton1 and isDropdownOpen then
                local mousePos = UserInputService:GetMouseLocation()
                local absPos = DropdownList.AbsolutePosition
                local absSize = DropdownList.AbsoluteSize
                
                if not (mousePos.X >= absPos.X and mousePos.X <= absPos.X + absSize.X and
                       mousePos.Y >= absPos.Y and mousePos.Y <= absPos.Y + absSize.Y) then
                    toggleDropdown()
                end
            end
        end)
        
        -- Add to elements list
        table.insert(self._dropdownElements, DropdownContainer)
        
        -- Update section size and positions
        local sectionsList = table.find(self._leftSections, section) and self._leftSections or self._rightSections
        local container = sectionsList == self._leftSections and LeftContainer or RightContainer
        
        -- Calculate new section height
        local contentHeight = 0
        for _, element in pairs(self._toggleElements) do
            if element.Parent == ContentFrame then
                contentHeight = contentHeight + element.Size.Y.Offset + 7
            end
        end
        for _, element in pairs(self._dropdownElements) do
            if element.Parent == ContentFrame then
                contentHeight = contentHeight + element.Size.Y.Offset + 7
            end
        end
        contentHeight = math.max(contentHeight - 7, 0)
        
        if windowInstance._sectionStates[section] then
            -- Only update if section is expanded
            section.Size = UDim2.new(1, 0, 0, 30 + contentHeight + 10)
            ContentFrame.Size = UDim2.new(1, 0, 0, contentHeight)
        end
        
        updateSectionPositions(container, sectionsList)
        
        return {
            Set = function(self, value)
                if multi then
                    -- Clear previous selection
                    for opt in pairs(selectedOptions) do
                        selectedOptions[opt] = nil
                    end
                    
                    -- Set new selection
                    if type(value) == "table" then
                        for _, option in ipairs(value) do
                            if table.find(options, option) then
                                selectedOptions[option] = true
                            end
                        end
                    end
                else
                    -- Clear previous selection
                    for opt in pairs(selectedOptions) do
                        selectedOptions[opt] = nil
                    end
                    
                    -- Set new selection
                    if table.find(options, value) then
                        selectedOptions[value] = true
                    end
                end
                
                -- Update UI
                updateSelectedText()
                createOptionButtons()
                
                -- Save state if needed
                if save and windowInstance._saveConfig.enabled then
                    if multi then
                        local selected = {}
                        for opt in pairs(selectedOptions) do
                            table.insert(selected, opt)
                        end
                        saveDropdownState(windowInstance, dropdownName, selected)
                    else
                        for opt in pairs(selectedOptions) do
                            saveDropdownState(windowInstance, dropdownName, opt)
                            break
                        end
                    end
                end
                
                if callback then
                    if multi then
                        local selected = {}
                        for opt in pairs(selectedOptions) do
                            table.insert(selected, opt)
                        end
                        callback(selected)
                    else
                        for opt in pairs(selectedOptions) do
                            callback(opt)
                            break
                        end
                    end
                end
            end,
            Get = function(self)
                if multi then
                    local selected = {}
                    for opt in pairs(selectedOptions) do
                        table.insert(selected, opt)
                    end
                    return selected
                else
                    for opt in pairs(selectedOptions) do
                        return opt
                    end
                    return nil
                end
            end,
            UpdateOptions = function(self, newOptions)
                options = newOptions
                
                -- Clear selections that are no longer in options
                for opt in pairs(selectedOptions) do
                    if not table.find(options, opt) then
                        selectedOptions[opt] = nil
                    end
                end
                
                -- Update UI
                updateSelectedText()
                createOptionButtons()
            end
        }
    end

    return windowInstance
end

return PizdecWare
