local success, HttpService = pcall(game.GetService, game, "HttpService")
local success2, TweenService = pcall(game.GetService, game, "TweenService")
local success3, UserInputService = pcall(game.GetService, game, "UserInputService")

if not (success and success2 and success3) or not HttpService or not TweenService or not UserInputService then
    warn("Required services are not available. Script may not function fully.")
    return
end

local PizdecWare = {}
PizdecWare.__index = PizdecWare

function PizdecWare:CreateWindow(guiName, infoText, saveName)
    local ScreenGui = Instance.new("ScreenGui")
    ScreenGui.Parent = game:GetService("CoreGui")
    ScreenGui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
    ScreenGui.Name = guiName

    -- Main window frame (Layer 1) - initially transparent
    local MainFrame = Instance.new("Frame")
    MainFrame.Name = "MainFrame"
    MainFrame.Parent = ScreenGui
    MainFrame.BackgroundColor3 = Color3.fromRGB(19, 21, 25)
    MainFrame.BorderSizePixel = 0
    MainFrame.Position = UDim2.new(0.032, 0, 0.195, 0)
    MainFrame.Size = UDim2.new(0, 630, 0, 460)
    MainFrame.BackgroundTransparency = 1 -- Start transparent
    MainFrame.Active = true
    MainFrame.ZIndex = 1

    local UICorner = Instance.new("UICorner")
    UICorner.Parent = MainFrame

    -- Improved dragging functionality
    local dragging = false
    local dragInput
    local dragStart
    local startPos

    local function update(input)
        local delta = input.Position - dragStart
        MainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
    end

    MainFrame.InputBegan:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseButton1 then
            dragging = true
            dragStart = input.Position
            startPos = MainFrame.Position
            
            input.Changed:Connect(function()
                if input.UserInputState == Enum.UserInputState.End then
                    dragging = false
                end
            end)
        end
    end)

    MainFrame.InputChanged:Connect(function(input)
        if input.UserInputType == Enum.UserInputType.MouseMovement then
            dragInput = input
        end
    end)

    UserInputService.InputChanged:Connect(function(input)
        if input == dragInput and dragging then
            update(input)
        end
    end)

    -- Logo with P and W letters
    local Logo = Instance.new("Frame")
    Logo.Name = "Logo"
    Logo.Parent = MainFrame
    Logo.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
    Logo.Size = UDim2.new(0, 25, 0, 25)
    Logo.Position = UDim2.new(0.022, 0, 0.031, 0)
    Logo.ZIndex = 3
    Logo.BackgroundTransparency = 1 -- Start transparent

    local UICorner_17 = Instance.new("UICorner")
    UICorner_17.Parent = Logo

    -- W letter
    local W = Instance.new("TextLabel")
    W.Name = "W"
    W.Parent = Logo
    W.BackgroundTransparency = 1
    W.Position = UDim2.new(0.282, 0, 0.76, 0)
    W.Size = UDim2.new(0, 23, 0, -14)
    W.ZIndex = 4
    W.Font = Enum.Font.SourceSansBold
    W.Text = "W"
    W.TextColor3 = Color3.fromRGB(0, 0, 0)
    W.TextSize = 20
    W.TextTransparency = 1 -- Start transparent

    -- P letter
    local P = Instance.new("TextLabel")
    P.Name = "P"
    P.Parent = Logo
    P.BackgroundTransparency = 1
    P.Position = UDim2.new(-0.304, 0, 0.76, 0)
    P.Size = UDim2.new(0, 27, 0, -14)
    P.ZIndex = 4
    P.Font = Enum.Font.SourceSansBold
    P.Text = "P"
    P.TextColor3 = Color3.fromRGB(255, 255, 255)
    P.TextSize = 20
    P.TextTransparency = 1 -- Start transparent

    -- PizdecWare label
    local PizdecWareLabel = Instance.new("TextLabel")
    PizdecWareLabel.Name = "PizdecWare"
    PizdecWareLabel.Parent = Logo
    PizdecWareLabel.BackgroundTransparency = 1
    PizdecWareLabel.Position = UDim2.new(2.2, 0, 1.3, 0)
    PizdecWareLabel.Size = UDim2.new(0, 60, 0, -41)
    PizdecWareLabel.Font = Enum.Font.SourceSansBold
    PizdecWareLabel.Text = "PizdecWare"
    PizdecWareLabel.TextColor3 = Color3.fromRGB(150, 17, 255)
    PizdecWareLabel.TextSize = 25
    PizdecWareLabel.TextTransparency = 1 -- Start transparent

    local Info = Instance.new("TextLabel")
    Info.Name = "Info"
    Info.Parent = MainFrame
    Info.BackgroundTransparency = 1
    Info.Position = UDim2.new(0.054, 0, 0.083, 0)
    Info.Size = UDim2.new(0, 116, 0, 10)
    Info.Font = Enum.Font.SourceSansBold
    Info.Text = infoText or ""
    Info.TextColor3 = Color3.fromRGB(170, 176, 183)
    Info.TextSize = 10
    Info.TextXAlignment = Enum.TextXAlignment.Right
    Info.TextTransparency = 1 -- Start transparent

    -- Main container - initially transparent
    local ElementContainer = Instance.new("ScrollingFrame")
    ElementContainer.Name = "ElementContainer"
    ElementContainer.Parent = MainFrame
    ElementContainer.BackgroundColor3 = Color3.fromRGB(23, 24, 28)
    ElementContainer.Position = UDim2.new(0.259, 0, 0.116, 0)
    ElementContainer.Size = UDim2.new(0, 460, 0, 400)
    ElementContainer.ZIndex = 1
    ElementContainer.BackgroundTransparency = 1 -- Start transparent
    ElementContainer.ScrollBarThickness = 8
    ElementContainer.ScrollBarImageColor3 = Color3.fromRGB(100, 100, 100)
    ElementContainer.CanvasSize = UDim2.new(0, 0, 0, 0)
    ElementContainer.AutomaticCanvasSize = Enum.AutomaticSize.Y

    local UICorner_2 = Instance.new("UICorner")
    UICorner_2.Parent = ElementContainer

    local UIStroke = Instance.new("UIStroke")
    UIStroke.Parent = ElementContainer
    UIStroke.Color = Color3.fromRGB(0, 0, 0)
    UIStroke.Thickness = 1
    UIStroke.Transparency = 0.8

    -- Section containers
    local LeftContainer = Instance.new("Frame")
    LeftContainer.Name = "LeftContainer"
    LeftContainer.Parent = ElementContainer
    LeftContainer.BackgroundTransparency = 1
    LeftContainer.Position = UDim2.new(0, 20, 0, 20)
    LeftContainer.Size = UDim2.new(0.5, -30, 1, -40)

    local RightContainer = Instance.new("Frame")
    RightContainer.Name = "RightContainer"
    RightContainer.Parent = ElementContainer
    RightContainer.BackgroundTransparency = 1
    RightContainer.Position = UDim2.new(0.5, 10, 0, 20)
    RightContainer.Size = UDim2.new(0.5, -30, 1, -40)

    -- Fade in animation function
    local function fadeIn(element)
        if not TweenService then return end
        local tweenInfo = TweenInfo.new(1, Enum.EasingStyle.Sine, Enum.EasingDirection.In)
        
        if element:IsA("TextLabel") or element:IsA("TextButton") then
            local tween = TweenService:Create(element, tweenInfo, {TextTransparency = 0})
            tween:Play()
        elseif element:IsA("ImageLabel") or element:IsA("ImageButton") then
            local tween = TweenService:Create(element, tweenInfo, {ImageTransparency = 0})
            tween:Play()
        elseif element:IsA("Frame") and element.Name:find("Toggle_") then
            -- Skip transparency animation for toggle containers
            return
        else
            local tween = TweenService:Create(element, tweenInfo, {BackgroundTransparency = 0})
            tween:Play()
        end
    end

    -- Create window instance to return
    local windowInstance = setmetatable({
        _tabZone = nil,
        _selectedTab = nil,
        _currentTab = nil,
        _tabSections = {},
        _initialized = false,
        _leftSections = {},
        _rightSections = {},
        _elementContainer = ElementContainer,
        _sectionStates = {}, -- Track expanded/collapsed state
        _toggleElements = {}, -- Track toggle elements
        _saveName = saveName or "PizdecWareSettings",
        _savedToggles = {}
    }, PizdecWare)

    -- Load saved toggles
    if saveName and HttpService then
        local success, data = pcall(function()
            return HttpService:JSONDecode(plugin:GetSetting(windowInstance._saveName) or {}
        end)
        if success and data then
            windowInstance._savedToggles = data
        end
    end

    -- Function to save toggle state
    local function saveToggleState(window, toggleName, state)
        if not window._saveName or not HttpService then return end
        
        window._savedToggles[toggleName] = state
        
        pcall(function()
            plugin:SetSetting(window._saveName, HttpService:JSONEncode(window._savedToggles))
        end)
    end

    -- Function to load toggle state
    local function loadToggleState(window, toggleName)
        if not window._saveName or not window._savedToggles then return nil end
        return window._savedToggles[toggleName]
    end

    -- Function to update positions of all sections with synchronized animation
    local function updateSectionPositions(container, sections)
        local yOffset = 0
        local totalHeight = 0
        
        -- First pass: calculate target positions
        local targetPositions = {}
        for i, section in ipairs(sections) do
            if section.Visible then
                -- Store target position
                targetPositions[section] = UDim2.new(0, 0, 0, yOffset)
                
                -- Calculate next yOffset based on current state
                if windowInstance._sectionStates[section] == false then -- Collapsed
                    yOffset = yOffset + 30 + 20
                else -- Expanded
                    -- Calculate section height based on number of elements
                    local elementCount = 0
                    for _, element in pairs(windowInstance._toggleElements) do
                        if element.Parent == section:FindFirstChild("ContentFrame") then
                            elementCount = elementCount + 1
                        end
                    end
                    
                    local sectionHeight = 30 + (elementCount * 25) + 15 -- Header + elements + padding
                    yOffset = yOffset + sectionHeight + 20
                end
                totalHeight = yOffset
            end
        end
        
        -- Second pass: apply new positions
        for section, position in pairs(targetPositions) do
            local tween = TweenService:Create(
                section,
                TweenInfo.new(0.3, Enum.EasingStyle.Quad),
                {Position = position}
            )
            tween:Play()
        end
        
        -- Update scroll container size
        windowInstance._elementContainer.CanvasSize = UDim2.new(0, 0, 0, totalHeight + 40)
    end

    -- Initialize UI elements
    coroutine.wrap(function()
        -- First fade in MainFrame and ElementContainer
        fadeIn(MainFrame)
        fadeIn(ElementContainer)
        wait(0.2)
        
        -- Then fade in logo and its elements
        fadeIn(Logo)
        fadeIn(W)
        fadeIn(P)
        fadeIn(PizdecWareLabel)
        fadeIn(Info)
        wait(0.3)
        
        -- Tab zone with correct positioning
        windowInstance._tabZone = Instance.new("Frame")
        windowInstance._tabZone.Name = "TabZone"
        windowInstance._tabZone.Parent = MainFrame
        windowInstance._tabZone.BackgroundTransparency = 1
        windowInstance._tabZone.Position = UDim2.new(0, 0, 0.116, 0)
        windowInstance._tabZone.Size = UDim2.new(0, 163, 0, 399)
        windowInstance._tabZone.ZIndex = 1

        -- Tabs label (50x20, centered text, left-aligned to MainFrame)
        local Tabs = Instance.new("TextLabel")
        Tabs.Name = "Tabs"
        Tabs.Parent = windowInstance._tabZone
        Tabs.BackgroundTransparency = 1
        Tabs.Position = UDim2.new(0.045, 0, 0, 0)
        Tabs.Size = UDim2.new(0, 50, 0, 20)
        Tabs.Font = Enum.Font.ArialBold
        Tabs.Text = "Tabs"
        Tabs.TextColor3 = Color3.fromRGB(147, 152, 156)
        Tabs.TextSize = 14
        Tabs.TextXAlignment = Enum.TextXAlignment.Left
        Tabs.ZIndex = 1
        fadeIn(Tabs)

        -- SelectedTab (Layer 2) with fixed 0.9 transparency
        windowInstance._selectedTab = Instance.new("Frame")
        windowInstance._selectedTab.Name = "SelectedTab"
        windowInstance._selectedTab.Parent = windowInstance._tabZone
        windowInstance._selectedTab.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
        windowInstance._selectedTab.BackgroundTransparency = 0.9
        windowInstance._selectedTab.Position = UDim2.new(0, 0, 0, 23)
        windowInstance._selectedTab.Size = UDim2.new(0, 163, 0, 30)
        windowInstance._selectedTab.ZIndex = 2
        fadeIn(windowInstance._selectedTab)

        -- Close button
        local CloseButton = Instance.new("ImageButton")
        CloseButton.Name = "CloseButton"
        CloseButton.Parent = MainFrame
        CloseButton.BackgroundTransparency = 1
        CloseButton.Position = UDim2.new(0.949, 0, 0.017, 0)
        CloseButton.Size = UDim2.new(0, 25, 0, 25)
        CloseButton.Image = "rbxassetid://12653789995"
        CloseButton.ZIndex = 3
        fadeIn(CloseButton)
        CloseButton.MouseButton1Click:Connect(function()
            ScreenGui:Destroy()
        end)

        windowInstance._initialized = true
    end)()

    function windowInstance:CreateTab(visualName, imageId)
        while not self._initialized do wait() end
        
        local tabCount = 0
        for _, child in ipairs(self._tabZone:GetChildren()) do
            if child:IsA("TextLabel") and child.Name ~= "Tabs" then
                tabCount = tabCount + 1
            end
        end
        
        local initialOffset = (23 + (tabCount * 30)) / self._tabZone.AbsoluteSize.Y
        
        local tab = Instance.new("TextLabel")
        tab.Name = visualName
        tab.Parent = self._tabZone
        tab.BackgroundTransparency = 1
        tab.Position = UDim2.new(0.307, 0, initialOffset, 0)
        tab.Size = UDim2.new(0, 101, 0, 28)
        tab.Font = Enum.Font.SourceSansBold
        tab.Text = visualName
        tab.TextColor3 = Color3.fromRGB(147, 152, 156)
        tab.TextSize = 20
        tab.TextXAlignment = Enum.TextXAlignment.Left
        tab.ZIndex = 3
        fadeIn(tab)

        local image = Instance.new("ImageLabel")
        image.Name = "TabImage"
        image.Parent = tab
        image.BackgroundTransparency = 1
        image.Position = UDim2.new(-0.365, 0, 0.037, 0)
        image.Size = UDim2.new(0, 26, 0, 26)
        image.ZIndex = 3
        image.Image = "rbxassetid://" .. imageId
        image.ImageColor3 = Color3.fromRGB(147, 152, 156)
        fadeIn(image)

        local function selectTab()
            if not TweenService or not self._selectedTab then return end
            
            local tweenInfo = TweenInfo.new(0.1, Enum.EasingStyle.Linear)
            
            -- Reset all tabs style
            for _, child in ipairs(self._tabZone:GetChildren()) do
                if child:IsA("TextLabel") and child ~= tab and child.Name ~= "Tabs" then
                    local childImage = child:FindFirstChild("TabImage")
                    TweenService:Create(child, tweenInfo, {TextColor3 = Color3.fromRGB(147, 152, 156)}):Play()
                    
                    if childImage then
                        TweenService:Create(childImage, tweenInfo, {ImageColor3 = Color3.fromRGB(147, 152, 156)}):Play()
                    end
                end
            end
            
            -- Apply style to selected tab
            TweenService:Create(tab, tweenInfo, {TextColor3 = Color3.fromRGB(150, 17, 255)}):Play()
            TweenService:Create(image, tweenInfo, {ImageColor3 = Color3.fromRGB(150, 17, 255)}):Play()

            -- Move selection indicator
            local newPosition = UDim2.new(0, 0, tab.Position.Y.Scale, 0)
            local moveTween = TweenService:Create(
                self._selectedTab, 
                TweenInfo.new(0.1, Enum.EasingStyle.Linear),
                {
                    Position = newPosition,
                    BackgroundTransparency = 0.9
                }
            )
            moveTween:Play()
            
            moveTween.Completed:Connect(function()
                self._selectedTab.BackgroundTransparency = 0.9
            end)

            -- Manage sections visibility
            for tabName, sections in pairs(self._tabSections) do
                for _, section in ipairs(sections) do
                    section.Visible = (tabName == tab.Name)
                end
            end

            -- Update positions for all sections
            for _, sections in pairs({self._leftSections, self._rightSections}) do
                updateSectionPositions(nil, sections)
            end

            self._currentTab = tab
        end

        tab.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                selectTab()
            end
        end)

        image.InputBegan:Connect(function(input)
            if input.UserInputType == Enum.UserInputType.MouseButton1 then
                selectTab()
            end
        end)

        if not self._currentTab then
            selectTab()
        end

        self._tabSections[tab.Name] = {}

        return tab
    end

    function windowInstance:CreateSection(sectionName, tab, side)
        if not tab then return nil end
        
        local container = (side == "left" and LeftContainer) or (side == "right" and RightContainer) or LeftContainer
        local sectionsList = (side == "left" and self._leftSections) or (side == "right" and self._rightSections) or self._leftSections
        
        -- Calculate initial position based on existing sections
        local yOffset = 0
        for _, section in ipairs(sectionsList) do
            if section.Visible then
                if windowInstance._sectionStates[section] == false then -- Collapsed
                    yOffset = yOffset + 30 + 20
                else -- Expanded
                    -- Calculate section height based on number of elements
                    local elementCount = 0
                    for _, element in pairs(self._toggleElements) do
                        if element.Parent == section:FindFirstChild("ContentFrame") then
                            elementCount = elementCount + 1
                        end
                    end
                    
                    local sectionHeight = 30 + (elementCount * 25) + 15 -- Header + elements + padding
                    yOffset = yOffset + sectionHeight + 20
                end
            end
        end

        local section = Instance.new("Frame")
        section.Name = sectionName
        section.Parent = container
        section.BackgroundColor3 = Color3.fromRGB(17, 19, 23)
        section.Position = UDim2.new(0, 0, 0, yOffset)
        
        -- Initial size (will be updated when elements are added)
        section.Size = UDim2.new(1, 0, 0, 30)
        section.ZIndex = 4
        section.Visible = (tab == self._currentTab)
        section.ClipsDescendants = true
        fadeIn(section)

        -- Set initial state to expanded
        windowInstance._sectionStates[section] = true

        local UICornerSection = Instance.new("UICorner")
        UICornerSection.CornerRadius = UDim.new(0, 3)
        UICornerSection.Parent = section

        -- Static header container
        local HeaderContainer = Instance.new("Frame")
        HeaderContainer.Name = "HeaderContainer"
        HeaderContainer.Parent = section
        HeaderContainer.BackgroundTransparency = 1
        HeaderContainer.Size = UDim2.new(1, 0, 0, 30)
        HeaderContainer.ZIndex = 5

        -- Section title
        local SectionLabel = Instance.new("TextLabel")
        SectionLabel.Name = "Label"
        SectionLabel.Parent = HeaderContainer
        SectionLabel.BackgroundTransparency = 1
        SectionLabel.Position = UDim2.new(0.085, 0, 0.15, 0)
        SectionLabel.Size = UDim2.new(0, 100, 0, 20)
        SectionLabel.Font = Enum.Font.ArialBold
        SectionLabel.Text = sectionName
        SectionLabel.TextColor3 = Color3.fromRGB(147, 152, 156)
        SectionLabel.TextSize = 14
        SectionLabel.TextXAlignment = Enum.TextXAlignment.Left
        SectionLabel.ZIndex = 5
        fadeIn(SectionLabel)

        -- Collapse button
        local ShowSectionButton = Instance.new("TextButton")
        ShowSectionButton.Name = "ShowSection"
        ShowSectionButton.Parent = HeaderContainer
        ShowSectionButton.BackgroundTransparency = 1
        ShowSectionButton.Position = UDim2.new(0.86, 0, 0.15, 0)
        ShowSectionButton.Size = UDim2.new(0, 20, 0, 20)
        ShowSectionButton.Font = Enum.Font.SourceSans
        ShowSectionButton.Text = "▼"
        ShowSectionButton.TextColor3 = Color3.fromRGB(147, 152, 156)
        ShowSectionButton.TextSize = 14
        ShowSectionButton.ZIndex = 5
        fadeIn(ShowSectionButton)

        -- Separator line (static position)
        local SectionLine = Instance.new("Frame")
        SectionLine.Name = "Line"
        SectionLine.Parent = HeaderContainer
        SectionLine.BackgroundColor3 = Color3.fromRGB(66, 63, 71)
        SectionLine.Position = UDim2.new(0.045, 0, 1, 0) -- Always at bottom of header
        SectionLine.Size = UDim2.new(0.91, 0, 0, 1)
        SectionLine.ZIndex = 4
        fadeIn(SectionLine)

        -- Content frame
        local ContentFrame = Instance.new("Frame")
        ContentFrame.Name = "ContentFrame"
        ContentFrame.Parent = section
        ContentFrame.BackgroundColor3 = Color3.fromRGB(17, 19, 23) -- Same as section background
        ContentFrame.BackgroundTransparency = 1
        ContentFrame.Position = UDim2.new(0, 0, 0, 31) -- Below the header and line
        ContentFrame.Size = UDim2.new(1, 0, 0, 0) -- Will be updated when elements are added
        ContentFrame.ZIndex = 4
        ContentFrame.ClipsDescendants = true

        -- Collapse animation
        local expandedSize = UDim2.new(1, 0, 0, 30) -- Will be updated when elements are added
        local collapsedSize = UDim2.new(1, 0, 0, 30)

        local function toggleSection()
            if not TweenService then return end
            
            local isExpanded = windowInstance._sectionStates[section]
            windowInstance._sectionStates[section] = not isExpanded
            
            if not isExpanded then
                -- Expand
                ShowSectionButton.Text = "▼"
                
                -- First make sure content frame is visible
                ContentFrame.BackgroundTransparency = 1
                
                -- Then show elements (without animation)
                for _, element in pairs(self._toggleElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = true
                        element.BackgroundTransparency = 1
                    end
                end
                
                -- Then expand
                local elementCount = 0
                for _, element in pairs(self._toggleElements) do
                    if element.Parent == ContentFrame then
                        elementCount = elementCount + 1
                    end
                end
                
                expandedSize = UDim2.new(1, 0, 0, 30 + (elementCount * 25) + 15)
                ContentFrame.Size = UDim2.new(1, 0, 0, elementCount * 25 + 15)
                
                local sizeTween = TweenService:Create(
                    section,
                    TweenInfo.new(0.3, Enum.EasingStyle.Quad),
                    {Size = expandedSize}
                )
                sizeTween:Play()
            else
                -- Collapse
                ShowSectionButton.Text = "▲"
                
                -- First hide elements (without animation)
                for _, element in pairs(self._toggleElements) do
                    if element.Parent == ContentFrame then
                        element.Visible = false
                        element.BackgroundTransparency = 1
                    end
                end
                
                -- Then collapse
                ContentFrame.Size = UDim2.new(1, 0, 0, 0)
                local sizeTween = TweenService:Create(
                    section,
                    TweenInfo.new(0.3, Enum.EasingStyle.Quad),
                    {Size = collapsedSize}
                )
                sizeTween:Play()
            end
            
            -- Update positions of all sections
            updateSectionPositions(container, sectionsList)
        end

        ShowSectionButton.MouseButton1Click:Connect(toggleSection)

        -- Add section to tab's sections list
        if not self._tabSections[tab.Name] then
            self._tabSections[tab.Name] = {}
        end
        table.insert(self._tabSections[tab.Name], section)
        
        -- Add to side sections list
        table.insert(sectionsList, section)
        
        -- Update scroll container size
        updateSectionPositions(container, sectionsList)

        return section
    end

    -- New function to create Toggle elements
    function windowInstance:CreateToggle(section, toggleName, defaultValue, callback, save)
        if not section then return nil end
        
        local ContentFrame = section:FindFirstChild("ContentFrame")
        if not ContentFrame then return nil end
        
        -- Load saved state if available
        if save and self._saveName then
            local savedState = loadToggleState(self, toggleName)
            if savedState ~= nil then
                defaultValue = savedState
            end
        end
        
        -- Calculate position based on existing toggles in this section
        local yOffset = 10 -- Start 10 pixels below the separator line
        for _, element in pairs(self._toggleElements) do
            if element.Parent == ContentFrame then
                yOffset = yOffset + 25 -- Each toggle is 25 pixels tall
            end
        end
        
        -- Toggle container
        local ToggleContainer = Instance.new("Frame")
        ToggleContainer.Name = "Toggle_" .. toggleName
        ToggleContainer.Parent = ContentFrame
        ToggleContainer.BackgroundTransparency = 1
        ToggleContainer.Size = UDim2.new(1, 0, 0, 25)
        ToggleContainer.Position = UDim2.new(0, 0, 0, yOffset)
        ToggleContainer.ZIndex = 5
        
        -- Toggle button (the square)
        local ToggleButton = Instance.new("TextButton")
        ToggleButton.Name = "Button"
        ToggleButton.Parent = ToggleContainer
        ToggleButton.BackgroundColor3 = defaultValue and Color3.fromRGB(150, 17, 255) or Color3.fromRGB(24, 29, 32)
        ToggleButton.BorderSizePixel = 0
        ToggleButton.Position = UDim2.new(0.085, 0, 0.1, 0)
        ToggleButton.Size = UDim2.new(0, 20, 0, 20)
        ToggleButton.Text = ""
        ToggleButton.ZIndex = 6
        
        local UICornerToggle = Instance.new("UICorner")
        UICornerToggle.CornerRadius = UDim.new(0, 4)
        UICornerToggle.Parent = ToggleButton
        
        -- Checkmark (only visible when toggle is on)
        local Checkmark = Instance.new("TextLabel")
        Checkmark.Name = "Checkmark"
        Checkmark.Parent = ToggleButton
        Checkmark.BackgroundTransparency = 1
        Checkmark.Size = UDim2.new(1, 0, 1, 0)
        Checkmark.Text = "✓"
        Checkmark.TextColor3 = Color3.fromRGB(24, 29, 32)
        Checkmark.TextSize = 16
        Checkmark.ZIndex = 7
        Checkmark.Visible = defaultValue
        
        -- Toggle text
        local ToggleText = Instance.new("TextLabel")
        ToggleText.Name = "Text"
        ToggleText.Parent = ToggleContainer
        ToggleText.BackgroundTransparency = 1
        ToggleText.Position = UDim2.new(0.15, 20, 0, 0)
        ToggleText.Size = UDim2.new(0.85, -20, 1, 0)
        ToggleText.Font = Enum.Font.SourceSansBold
        ToggleText.Text = toggleName
        ToggleText.TextColor3 = Color3.fromRGB(147, 152, 156)
        ToggleText.TextSize = 17
        ToggleText.TextXAlignment = Enum.TextXAlignment.Left
        ToggleText.ZIndex = 6
        
        -- Toggle functionality
        local isToggled = defaultValue or false
        
        ToggleButton.MouseButton1Click:Connect(function()
            isToggled = not isToggled
            
            if isToggled then
                ToggleButton.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
                Checkmark.Visible = true
            else
                ToggleButton.BackgroundColor3 = Color3.fromRGB(24, 29, 32)
                Checkmark.Visible = false
            end
            
            -- Save state if needed
            if save then
                saveToggleState(self, toggleName, isToggled)
            end
            
            if callback then
                callback(isToggled)
            end
        end)
        
        -- Add to elements list
        table.insert(self._toggleElements, ToggleContainer)
        
        -- Update section size and positions
        local sectionsList = table.find(self._leftSections, section) and self._leftSections or self._rightSections
        local container = sectionsList == self._leftSections and LeftContainer or RightContainer
        
        -- Calculate new section height
        local elementCount = 0
        for _, element in pairs(self._toggleElements) do
            if element.Parent == ContentFrame then
                elementCount = elementCount + 1
            end
        end
        
        local sectionHeight = 30 + (elementCount * 25) + 15
        
        if windowInstance._sectionStates[section] then
            -- Only update if section is expanded
            section.Size = UDim2.new(1, 0, 0, sectionHeight)
            ContentFrame.Size = UDim2.new(1, 0, 0, elementCount * 25 + 15)
        end
        
        updateSectionPositions(container, sectionsList)
        
        return {
            Set = function(self, value)
                isToggled = value
                
                if isToggled then
                    ToggleButton.BackgroundColor3 = Color3.fromRGB(150, 17, 255)
                    Checkmark.Visible = true
                else
                    ToggleButton.BackgroundColor3 = Color3.fromRGB(24, 29, 32)
                    Checkmark.Visible = false
                end
                
                -- Save state if needed
                if save then
                    saveToggleState(windowInstance, toggleName, isToggled)
                end
                
                if callback then
                    callback(isToggled)
                end
            end,
            Get = function(self)
                return isToggled
            end
        }
    end

    return windowInstance
end

return PizdecWare
